# Francis Poulizac <fpoulizac@vivaldi.net>, 2021.
# Francis Poulizac <francis@poulizac.fr>, 2022.
msgid ""
msgstr ""
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"PO-Revision-Date: 2022-12-30 18:51+0000\n"
"Last-Translator: Francis Poulizac <francis@poulizac.fr>\n"
"Language-Team: French <https://hosted.weblate.org/projects/klipper/"
"code_overview/fr/>\n"
"Language: fr\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n > 1;\n"
"X-Generator: Weblate 4.15.1-dev\n"

msgid ""
"This document describes the overall code layout and major code flow of "
"Klipper."
msgstr ""
"Ce document décrit la disposition générale du code et le flux de code "
"principal de Klipper."

msgid "Directory Layout"
msgstr "Disposition du répertoire"

msgid ""
"The **src/** directory contains the C source for the micro-controller code. "
"The **src/atsam/**, **src/atsamd/**, **src/avr/**, **src/linux/**, "
"**src/lpc176x/**, **src/pru/**, and **src/stm32/** directories contain "
"architecture specific micro-controller code. The **src/simulator/** contains"
" code stubs that allow the micro-controller to be test compiled on other "
"architectures. The **src/generic/** directory contains helper code that may "
"be useful across different architectures. The build arranges for includes of"
" \"board/somefile.h\" to first look in the current architecture directory "
"(eg, src/avr/somefile.h) and then in the generic directory (eg, "
"src/generic/somefile.h)."
msgstr ""
"Le répertoire **src/** contient les sources C du code du micro-contrôleur. "
"Les répertoires **src/atsam/**, **src/atsamd/**, **src/avr/**, **src/linux/**"
", **src/lpc176x/**, **src/pru/**, et **src/stm32/** contiennent le code du "
"micro-contrôleur spécifique à chaque architecture. Le répertoire **src/"
"simulator/** contient des éléments de remplacement de code permettant de "
"tester la compilation du micro-contrôleur sur d'autres architectures. Le "
"répertoire **src/generic/** contient du code d'assistance utile sur "
"différentes architectures. La compilation fait en sorte que les inclusions "
"de \"board/somefile.h\" soient d'abord recherchées dans le répertoire de "
"l'architecture courante (par exemple, src/avr/somefile.h) et ensuite dans le "
"répertoire générique (par exemple, src/generic/somefile.h)."

msgid ""
"The **klippy/** directory contains the host software. Most of the host "
"software is written in Python, however the **klippy/chelper/** directory "
"contains some C code helpers. The **klippy/kinematics/** directory contains "
"the robot kinematics code. The **klippy/extras/** directory contains the "
"host code extensible \"modules\"."
msgstr ""
"Le répertoire **klippy/** contient le logiciel hôte. La majorité du logiciel "
"hôte est écrit en Python, cependant le répertoire **klippy/chelper/** "
"contient quelques assistants en code C. Le répertoire **klippy/kinematics/** "
"contient le code lié à la cinématique du robot. Le répertoire **klippy/"
"extras/** contient les \"modules\" extensibles du code hôte."

msgid ""
"The **lib/** directory contains external 3rd-party library code that is "
"necessary to build some targets."
msgstr ""
"Le répertoire **lib/** contient du code de bibliothèque externe de tierce "
"partie nécessaire à la construction de certaines cibles."

msgid ""
"The **config/** directory contains example printer configuration files."
msgstr ""
"Le répertoire **config/** contient des exemples de fichiers de configuration "
"d'imprimante."

msgid ""
"The **scripts/** directory contains build-time scripts useful for compiling "
"the micro-controller code."
msgstr ""
"Le répertoire **scripts/** contient des scripts de construction utiles à la "
"compilation du code du micro-contrôleur."

msgid "The **test/** directory contains automated test cases."
msgstr "Le répertoire **test/** contient des cas de tests automatisés."

msgid ""
"During compilation, the build may create an **out/** directory. This "
"contains temporary build time objects. The final micro-controller object "
"that is built is **out/klipper.elf.hex** on AVR and **out/klipper.bin** on "
"ARM."
msgstr ""
"Pendant la compilation, le constructeur peut créer un répertoire **out/**. "
"Celui-ci contient des objets temporaires de compilation. L'objet micro-"
"contrôleur final qui est construit est **out/klipper.elf.hex** sur AVR et **"
"out/klipper.bin** sur ARM."

msgid "Micro-controller code flow"
msgstr "Flux de code du micro-contrôleur"

msgid ""
"Execution of the micro-controller code starts in architecture specific code "
"(eg, **src/avr/main.c**) which ultimately calls sched_main() located in "
"**src/sched.c**. The sched_main() code starts by running all functions that "
"have been tagged with the DECL_INIT() macro. It then goes on to repeatedly "
"run all functions tagged with the DECL_TASK() macro."
msgstr ""
"L'exécution du code du microcontrôleur débute dans le code spécifique à "
"l'architecture (par exemple, **src/avr/main.c**) qui appelle finalement "
"sched_main() situé dans **src/sched.c**. Le code sched_main() commence par "
"exécuter toutes les fonctions marquées avec la macro DECL_INIT(). Il exécute "
"ensuite de manière répétée toutes les fonctions marquées par la macro "
"DECL_TASK()."

msgid ""
"One of the main task functions is command_dispatch() located in "
"**src/command.c**. This function is called from the board specific "
"input/output code (eg, **src/avr/serial.c**, **src/generic/serial_irq.c**) "
"and it runs the command functions associated with the commands found in the "
"input stream. Command functions are declared using the DECL_COMMAND() macro "
"(see the [protocol](Protocol.md) document for more information)."
msgstr ""
"L'une des principales fonctions de la tâche est command_dispatch() située "
"dans **src/command.c**. Cette fonction est appelée à partir du code d'entrée/"
"sortie spécifique à la carte (par exemple, **src/avr/serial.c**, **src/"
"generic/serial_irq.c**) et elle exécute les fonctions de commande associées "
"aux commandes trouvées dans le flux d'entrée. Les fonctions de commande sont "
"déclarées à l'aide de la macro DECL_COMMAND() (voir le document "
"[protocole](Protocol.md) pour plus d'informations)."

msgid ""
"Timer functions are scheduled by calling sched_add_timer() (located in "
"**src/sched.c**). The scheduler code will arrange for the given function to "
"be called at the requested clock time. Timer interrupts are initially "
"handled in an architecture specific interrupt handler (eg, "
"**src/avr/timer.c**) which calls sched_timer_dispatch() located in "
"**src/sched.c**. The timer interrupt leads to execution of schedule timer "
"functions. Timer functions always run with interrupts disabled. The timer "
"functions should always complete within a few micro-seconds. At completion "
"of the timer event, the function may choose to reschedule itself."
msgstr ""
"Les fonctions de temporisation sont programmées en appelant sched_add_timer()"
" (situé dans **src/sched.c**). Le code du planificateur s'arrangera pour que "
"la fonction donnée soit appelée au moment demandé. Les interruptions de "
"temporisation sont initialement traitées dans un gestionnaire d'interruption "
"spécifique à l'architecture (par exemple, **src/avr/timer.c**) qui appelle "
"sched_timer_dispatch() situé dans **src/sched.c**. L'interruption de la "
"temporisation entraîne l'exécution des fonctions de temporisation "
"planifiées. Les fonctions de temporisation sont toujours exécutées avec des "
"interruptions désactivées. Les fonctions de temporisation devraient toujours "
"se terminer en quelques microsecondes. À la fin de l'événement de "
"temporisation, la fonction peut choisir de se reprogrammer."

msgid ""
"In the event an error is detected the code can invoke shutdown() (a macro "
"which calls sched_shutdown() located in **src/sched.c**). Invoking "
"shutdown() causes all functions tagged with the DECL_SHUTDOWN() macro to be "
"run. Shutdown functions always run with interrupts disabled."
msgstr ""
"En cas de détection d'erreur, le code peut invoquer shutdown() (une macro "
"qui appelle sched_shutdown() située dans **src/sched.c**). L'appel à "
"shutdown() entraîne l'exécution de toutes les fonctions marquées par la "
"macro DECL_SHUTDOWN(). Les fonctions d'arrêt s'exécutent toujours avec des "
"interruptions désactivées."

msgid ""
"Much of the functionality of the micro-controller involves working with "
"General-Purpose Input/Output pins (GPIO). In order to abstract the low-level"
" architecture specific code from the high-level task code, all GPIO events "
"are implemented in architecture specific wrappers (eg, **src/avr/gpio.c**). "
"The code is compiled with gcc's \"-flto -fwhole-program\" optimization which"
" does an excellent job of inlining functions across compilation units, so "
"most of these tiny gpio functions are inlined into their callers, and there "
"is no run-time cost to using them."
msgstr ""
"Une grande partie des fonctionnalités du micro-contrôleur implique de "
"travailler avec des broches d'entrée/sortie à usage général (GPIO). Afin de "
"séparer le code de bas niveau spécifique à l'architecture du code de haut "
"niveau de la tâche, tous les événements GPIO sont implémentés dans des "
"emballages spécifiques à l'architecture (par exemple, **src/avr/gpio.c**). "
"Le code est compilé avec l'optimisation \"-flto -fwhole-program\" de gcc qui "
"fait un excellent travail d'intégration des fonctions à travers les unités "
"de compilation, ainsi la plupart de ces minuscules fonctions gpio sont "
"intégrées à leurs appelants, et il n'y a aucun coût d'exécution à les "
"utiliser."

msgid "Klippy code overview"
msgstr "Aperçu du code Klippy"

msgid ""
"The host code (Klippy) is intended to run on a low-cost computer (such as a "
"Raspberry Pi) paired with the micro-controller. The code is primarily "
"written in Python, however it does use CFFI to implement some functionality "
"in C code."
msgstr ""
"Le code hôte (Klippy) est destiné à fonctionner sur un ordinateur à petit "
"prix (tel qu'un Raspberry Pi) associé au microcontrôleur. Le code est "
"principalement écrit en Python, cependant il utilise CFFI pour implémenter "
"certaines fonctionnalités en code C."

msgid ""
"Initial execution starts in **klippy/klippy.py**. This reads the command-"
"line arguments, opens the printer config file, instantiates the main printer"
" objects, and starts the serial connection. The main execution of G-code "
"commands is in the process_commands() method in **klippy/gcode.py**. This "
"code translates the G-code commands into printer object calls, which "
"frequently translate the actions to commands to be executed on the micro-"
"controller (as declared via the DECL_COMMAND macro in the micro-controller "
"code)."
msgstr ""
"L'exécution initiale commence dans **klippy/klippy.py**. Ceci lit les "
"arguments de la ligne de commande, ouvre le fichier de configuration de "
"l'imprimante, instancie les principaux objets de l'imprimante et lance la "
"connexion série. L'exécution principale des commandes G-code se fait dans la "
"méthode process_commands() de **klippy/gcode.py**. Ce code traduit les "
"commandes G-code en appels d'objets d'imprimante fréquemment traduis en "
"commandes d'actions à exécuter sur le micro-contrôleur (tel que déclaré via "
"la macro DECL_COMMAND dans le code du micro-contrôleur)."

msgid ""
"There are four threads in the Klippy host code. The main thread handles "
"incoming gcode commands. A second thread (which resides entirely in the "
"**klippy/chelper/serialqueue.c** C code) handles low-level IO with the "
"serial port. The third thread is used to process response messages from the "
"micro-controller in the Python code (see **klippy/serialhdl.py**). The "
"fourth thread writes debug messages to the log (see "
"**klippy/queuelogger.py**) so that the other threads never block on log "
"writes."
msgstr ""
"Il y a quatre threads dans le code hôte de Klippy. Le thread principal gère "
"les commandes gcode entrantes. Un deuxième thread (résidant entièrement dans "
"le code C **klippy/chelper/serialqueue.c**) gère les entrées/sorties de bas "
"niveau avec le port série. Le troisième thread est utilisé pour traiter les "
"messages de réponse du micro-contrôleur dans le code Python (voir **klippy/"
"serialhdl.py**). Le quatrième thread écrit les messages de débogage dans le "
"journal (voir **klippy/queuelogger.py**) afin que les autres threads ne "
"bloquent jamais les écritures dans le journal."

msgid "Code flow of a move command"
msgstr "Flux du code d'une commande de déplacement"

msgid ""
"A typical printer movement starts when a \"G1\" command is sent to the "
"Klippy host and it completes when the corresponding step pulses are produced"
" on the micro-controller. This section outlines the code flow of a typical "
"move command. The [kinematics](Kinematics.md) document provides further "
"information on the mechanics of moves."
msgstr ""
"Un mouvement typique de l'imprimante commence lorsqu'une commande \"G1\" est "
"envoyée à l'hôte Klippy et se termine lorsque les impulsions de pas "
"correspondantes sont produites sur le micro-contrôleur. Cette section décrit "
"le flux du code d'une commande de déplacement typique. Le document "
"[cinématiques](Kinematics.md) fournit des informations supplémentaires sur "
"la mécanique des mouvements."

msgid ""
"Processing for a move command starts in gcode.py. The goal of gcode.py is to"
" translate G-code into internal calls. A G1 command will invoke cmd_G1() in "
"klippy/extras/gcode_move.py. The gcode_move.py code handles changes in "
"origin (eg, G92), changes in relative vs absolute positions (eg, G90), and "
"unit changes (eg, F6000=100mm/s). The code path for a move is: "
"`_process_data() -> _process_commands() -> cmd_G1()`. Ultimately the "
"ToolHead class is invoked to execute the actual request: `cmd_G1() -> "
"ToolHead.move()`"
msgstr ""
"Le traitement d'une commande de déplacement commence dans gcode.py. Le but "
"de gcode.py est de traduire le G-code en appels internes. Une commande G1 "
"invoquera cmd_G1() dans klippy/extras/gcode_move.py. Le code gcode_move.py "
"gère les changements d'origine (par exemple, G92), les changements de "
"positions relatives et absolues (par exemple, G90), et les changements "
"d'unités (par exemple, F6000=100mm/s). Le chemin du code pour un déplacement "
"est : `_process_data() -> _process_commands() -> cmd_G1()`. Finalement, la "
"classe ToolHead est invoquée pour exécuter la demande réelle : `cmd_G1() -> "
"ToolHead.move()`"

msgid ""
"The ToolHead class (in toolhead.py) handles \"look-ahead\" and tracks the "
"timing of printing actions. The main codepath for a move is: "
"`ToolHead.move() -> MoveQueue.add_move() -> MoveQueue.flush() -> "
"Move.set_junction() -> ToolHead._process_moves()`."
msgstr ""
"La classe ToolHead (dans toolhead.py) gère le \"look-ahead\" et suit la "
"temporisation des actions d'impression. Le chemin du code principal pour un "
"déplacement est : `ToolHead.move() -> MoveQueue.add_move() -> MoveQueue."
"flush() -> Move.set_junction() -> ToolHead._process_moves()`."

msgid ""
"ToolHead.move() creates a Move() object with the parameters of the move (in "
"cartesian space and in units of seconds and millimeters)."
msgstr ""
"ToolHead.move() crée un objet Move() avec les paramètres du déplacement ("
"dans l'espace cartésien et en unités de secondes et de millimètres)."

msgid ""
"The kinematics class is given the opportunity to audit each move "
"(`ToolHead.move() -> kin.check_move()`). The kinematics classes are located "
"in the klippy/kinematics/ directory. The check_move() code may raise an "
"error if the move is not valid. If check_move() completes successfully then "
"the underlying kinematics must be able to handle the move."
msgstr ""
"La classe cinématique a la possibilité de vérifier chaque mouvement "
"(`ToolHead.move() -> kin.check_move()`). Les classes cinématiques sont "
"situées dans le répertoire klippy/kinematics/. Le code check_move() peut "
"lever une erreur si le déplacement n'est pas valide. Si check_move() se "
"termine avec succès, alors la cinématique sous-jacente doit être capable de "
"gérer le déplacement."

msgid "MoveQueue.add_move() places the move object on the \"look-ahead\" queue."
msgstr ""
"MoveQueue.add_move() place l'objet move dans la file d'attente \"look-ahead\""
"."

msgid ""
"MoveQueue.flush() determines the start and end velocities of each move."
msgstr ""
"MoveQueue.flush() détermine les vitesses de début et de fin de chaque "
"mouvement."

msgid ""
"Move.set_junction() implements the \"trapezoid generator\" on a move. The "
"\"trapezoid generator\" breaks every move into three parts: a constant "
"acceleration phase, followed by a constant velocity phase, followed by a "
"constant deceleration phase. Every move contains these three phases in this "
"order, but some phases may be of zero duration."
msgstr ""
"Move.set_junction() implémente le \"générateur de trapèze\" sur un "
"mouvement. Le \"générateur de trapèze\" divise chaque mouvement en trois "
"parties : une phase d'accélération constante, suivie d'une phase de vitesse "
"constante, puis d'une phase de décélération constante. Chaque déplacement "
"contient ces trois phases dans cet ordre, certaines phases pouvant être de "
"durée nulle."

msgid ""
"When ToolHead._process_moves() is called, everything about the move is known"
" - its start location, its end location, its acceleration, its "
"start/cruising/end velocity, and distance traveled during "
"acceleration/cruising/deceleration. All the information is stored in the "
"Move() class and is in cartesian space in units of millimeters and seconds."
msgstr ""
"Lorsque ToolHead._process_moves() est appelé, tout ce qui concerne le "
"déplacement est connu : sa position de départ, sa position d'arrivée, son "
"accélération, sa vitesse de départ/de croisière/de fin, et la distance "
"parcourue pendant l'accélération/la croisière/la décélération. Toutes ces "
"informations sont stockées dans la classe Move() et sont dans l'espace "
"cartésien en unités de millimètres et de secondes."

msgid ""
"Klipper uses an [iterative solver](https://en.wikipedia.org/wiki/Root-"
"finding_algorithm) to generate the step times for each stepper. For "
"efficiency reasons, the stepper pulse times are generated in C code. The "
"moves are first placed on a \"trapezoid motion queue\": "
"`ToolHead._process_moves() -> trapq_append()` (in klippy/chelper/trapq.c). "
"The step times are then generated: `ToolHead._process_moves() -> "
"ToolHead._update_move_time() -> MCU_Stepper.generate_steps() -> "
"itersolve_generate_steps() -> itersolve_gen_steps_range()` (in "
"klippy/chelper/itersolve.c). The goal of the iterative solver is to find "
"step times given a function that calculates a stepper position from a time. "
"This is done by repeatedly \"guessing\" various times until the stepper "
"position formula returns the desired position of the next step on the "
"stepper. The feedback produced from each guess is used to improve future "
"guesses so that the process rapidly converges to the desired time. The "
"kinematic stepper position formulas are located in the klippy/chelper/ "
"directory (eg, kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c)."
msgstr ""
"Klipper utilise un [solveur itératif](https://en.wikipedia.org/wiki/Root-"
"finding_algorithm) afin de générer les délais des pas pour chaque moteur pas "
"à pas. Pour des raisons d'efficacité, les délais d'impulsion des pas sont "
"générés en code C. Les mouvements sont d'abord placés dans une \"file "
"d'attente de mouvements trapézoïdaux\" : `ToolHead._process_moves() -> "
"trapq_append()` (dans klippy/chelper/trapq.c). Les délais de pas sont "
"ensuite générés : `ToolHead._process_moves() -> ToolHead._update_move_time() "
"-> MCU_Stepper.generate_steps() -> itersolve_generate_steps() -> "
"itersolve_gen_steps_range()` (dans klippy/chelper/itersolve.c). Le but du "
"solveur itératif est de trouver les délais de pas à partir d'une fonction "
"calculant la position du moteur à partir du temps. Ceci est fait en "
"\"devinant\" de manière répétée plusieurs délais jusqu'à ce que la formule "
"de position du pas renvoie la position désirée du pas suivant sur le moteur. "
"Le retour d'information produit par chaque estimation est utilisé afin "
"d'améliorer les estimations futures, de sorte que le processus converge "
"rapidement vers le délai souhaité. Les formules de position cinématique du "
"moteur sont situées dans le répertoire klippy/chelper/ (par exemple, "
"kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c)."

msgid ""
"Note that the extruder is handled in its own kinematic class: "
"`ToolHead._process_moves() -> PrinterExtruder.move()`. Since the Move() "
"class specifies the exact movement time and since step pulses are sent to "
"the micro-controller with specific timing, stepper movements produced by the"
" extruder class will be in sync with head movement even though the code is "
"kept separate."
msgstr ""
"Notez que l'extrudeuse est gérée dans sa propre classe cinématique : "
"`ToolHead._process_moves() -> PrinterExtruder.move()`. Puisque la classe "
"Move() spécifie le délai exact du mouvement et que les impulsions de pas "
"sont envoyées au micro-contrôleur avec un timing spécifique, les mouvements "
"du moteur produits par la classe de l'extrudeuse seront synchronisés avec le "
"mouvement de la tête même si le code est séparé."

msgid ""
"After the iterative solver calculates the step times they are added to an "
"array: `itersolve_gen_steps_range() -> stepcompress_append()` (in "
"klippy/chelper/stepcompress.c). The array (struct stepcompress.queue) stores"
" the corresponding micro-controller clock counter times for every step. Here"
" the \"micro-controller clock counter\" value directly corresponds to the "
"micro-controller's hardware counter - it is relative to when the micro-"
"controller was last powered up."
msgstr ""
"Après que le solveur itératif ait calculé les délais de pas, ils sont "
"ajoutés à un tableau : `itersolve_gen_steps_range() -> stepcompress_append()`"
" (dans klippy/chelper/stepcompress.c). Le tableau (struct stepcompress.queue)"
" stocke les durées correspondantes du compteur d'horloge du micro-contrôleur "
"pour chaque étape. Ici, la valeur du \"compteur d'horloge du micro-"
"contrôleur\" correspond directement au compteur matériel du micro-contrôleur "
"- elle est relative à la dernière mise sous tension du micro-contrôleur."

msgid ""
"The next major step is to compress the steps: `stepcompress_flush() -> "
"compress_bisect_add()` (in klippy/chelper/stepcompress.c). This code "
"generates and encodes a series of micro-controller \"queue_step\" commands "
"that correspond to the list of stepper step times built in the previous "
"stage. These \"queue_step\" commands are then queued, prioritized, and sent "
"to the micro-controller (via stepcompress.c:steppersync and "
"serialqueue.c:serialqueue)."
msgstr ""
"La prochaine étape majeure est de compresser les étapes : "
"`stepcompress_flush() -> compress_bisect_add()` (dans klippy/chelper/"
"stepcompress.c). Ce code génère et encode une série de commandes \"queue_step"
"\" du micro-contrôleur correspondant à la liste des durées de pas du moteur "
"construite à l'étape précédente. Ces commandes \"queue_step\" sont ensuite "
"mises en file d'attente, hiérarchisées et envoyées au micro-contrôleur (via "
"stepcompress.c:steppersync et serialqueue.c:serialqueue)."

msgid ""
"Processing of the queue_step commands on the micro-controller starts in "
"src/command.c which parses the command and calls `command_queue_step()`. The"
" command_queue_step() code (in src/stepper.c) just appends the parameters of"
" each queue_step command to a per stepper queue. Under normal operation the "
"queue_step command is parsed and queued at least 100ms before the time of "
"its first step. Finally, the generation of stepper events is done in "
"`stepper_event()`. It's called from the hardware timer interrupt at the "
"scheduled time of the first step. The stepper_event() code generates a step "
"pulse and then reschedules itself to run at the time of the next step pulse "
"for the given queue_step parameters. The parameters for each queue_step "
"command are \"interval\", \"count\", and \"add\". At a high-level, "
"stepper_event() runs the following, 'count' times: `do_step(); "
"next_wake_time = last_wake_time + interval; interval += add;`"
msgstr ""
"Le traitement des commandes queue_step sur le micro-contrôleur commence dans "
"src/command.c qui analyse la commande et appelle `command_queue_step()`. Le "
"code command_queue_step() (dans src/stepper.c) ajoute simplement les "
"paramètres de chaque commande queue_step à une file d'attente par moteur. En "
"fonctionnement normal, la commande queue_step est analysée et mise en file "
"d'attente au moins 100ms avant le moment de son premier pas. Enfin, la "
"génération des événements de pas du moteur est faite dans `stepper_event()`. "
"Elle est appelée depuis l'interruption du compteur matériel à l'heure prévue "
"du premier pas. Le code stepper_event() génère une impulsion de pas et se "
"reprogramme ensuite pour s'exécuter au moment de l'impulsion de pas suivante "
"pour les paramètres queue_step donnés. Les paramètres pour chaque commande "
"queue_step sont \"interval\", \"count\", et \"add\". A un haut niveau, "
"stepper_event() exécute la commande suivante, 'count' fois : `do_step() ; "
"next_wake_time = last_wake_time + interval ; interval += add;`"

msgid ""
"The above may seem like a lot of complexity to execute a movement. However, "
"the only really interesting parts are in the ToolHead and kinematic classes."
" It's this part of the code which specifies the movements and their timings."
" The remaining parts of the processing is mostly just communication and "
"plumbing."
msgstr ""
"Ce qui précède peut sembler beaucoup de complexité pour l'exécution d'un "
"mouvement. Cependant, les seules parties vraiment intéressantes se trouvent "
"dans les classes ToolHead et kinematic. C'est cette partie du code qui "
"précise les mouvements et leurs durées. Les autres parties du traitement "
"sont essentiellement de la communication et de la plomberie."

msgid "Adding a host module"
msgstr "Ajout d'un module hôte"

msgid ""
"The Klippy host code has a dynamic module loading capability. If a config "
"section named \"[my_module]\" is found in the printer config file then the "
"software will automatically attempt to load the python module "
"klippy/extras/my_module.py . This module system is the preferred method for "
"adding new functionality to Klipper."
msgstr ""
"Le code hôte de Klippy a une capacité de chargement dynamique de modules. Si "
"une section de configuration nommée \"[mon_module]\" est trouvée dans le "
"fichier de configuration de l'imprimante, le logiciel tentera "
"automatiquement de charger le module python klippy/extras/mon_module.py . Ce "
"système de modules est la méthode préférée pour ajouter de nouvelles "
"fonctionnalités à Klipper."

msgid ""
"The easiest way to add a new module is to use an existing module as a "
"reference - see **klippy/extras/servo.py** as an example."
msgstr ""
"La façon la plus simple d'ajouter un nouveau module est d'utiliser un module "
"existant comme référence - voir **klippy/extras/servo.py** comme exemple."

msgid "The following may also be useful:"
msgstr "Les éléments suivants peuvent également être utiles :"

msgid ""
"Execution of the module starts in the module level `load_config()` function "
"(for config sections of the form [my_module]) or in `load_config_prefix()` "
"(for config sections of the form [my_module my_name]). This function is "
"passed a \"config\" object and it must return a new \"printer object\" "
"associated with the given config section."
msgstr ""
"L'exécution du module commence dans la fonction `load_config()` au niveau du "
"module (pour les sections de configuration de la forme [mon_module]) ou dans "
"`load_config_prefix()` (pour les sections de configuration de la forme ["
"mon_module mon_nom]). On passe à cette fonction un objet \"config\" et elle "
"doit retourner un nouvel \"objet imprimante\" associé à la section de "
"configuration donnée."

msgid ""
"During the process of instantiating a new printer object, the config object "
"can be used to read parameters from the given config section. This is done "
"using `config.get()`, `config.getfloat()`, `config.getint()`, etc. methods. "
"Be sure to read all values from the config during the construction of the "
"printer object - if the user specifies a config parameter that is not read "
"during this phase then it will be assumed it is a typo in the config and an "
"error will be raised."
msgstr ""
"Durant le processus d'instanciation d'un nouvel objet imprimante, l'objet "
"config peut être utilisé pour lire les paramètres de la section config "
"donnée. Ceci est fait en utilisant les méthodes `config.get()`, `config."
"getfloat()`, `config.getint()`, etc. Assurez-vous de lire toutes les valeurs "
"de la configuration pendant la construction de l'objet imprimante - si "
"l'utilisateur spécifie un paramètre de configuration qui n'est pas lu "
"pendant cette phase, il sera supposé qu'il s'agit d'une faute de frappe dans "
"la configuration et une erreur sera levée."

msgid ""
"Use the `config.get_printer()` method to obtain a reference to the main "
"\"printer\" class. This \"printer\" class stores references to all the "
"\"printer objects\" that have been instantiated. Use the "
"`printer.lookup_object()` method to find references to other printer "
"objects. Almost all functionality (even core kinematic modules) are "
"encapsulated in one of these printer objects. Note, though, that when a new "
"module is instantiated, not all other printer objects will have been "
"instantiated. The \"gcode\" and \"pins\" modules will always be available, "
"but for other modules it is a good idea to defer the lookup."
msgstr ""
"Utilisez la méthode `config.get_printer()` pour obtenir une référence à la "
"classe principale \"printer\". Cette classe \"printer\" stocke les "
"références de tous les \"objets imprimante\" instanciés. Utilisez la méthode "
"`printer.lookup_object()` pour trouver des références à d'autres objets "
"imprimante. Presque toutes les fonctionnalités (même les modules "
"cinématiques de base) sont encapsulées dans un de ces objets imprimante. "
"Notez, cependant, que lorsqu'un nouveau module est instancié, tous les "
"autres objets d'impression n'auront pas encore été instanciés. Les modules "
"\"gcode\" et \"pins\" seront toujours disponibles, mais pour les autres "
"modules, il est préférable de différer la recherche."

msgid ""
"Register event handlers using the `printer.register_event_handler()` method "
"if the code needs to be called during \"events\" raised by other printer "
"objects. Each event name is a string, and by convention it is the name of "
"the main source module that raises the event along with a short name for the"
" action that is occurring (eg, \"klippy:connect\"). The parameters passed to"
" each event handler are specific to the given event (as are exception "
"handling and execution context). Two common startup events are:"
msgstr ""
"Enregistrez les gestionnaires d'événements en utilisant la méthode `printer."
"register_event_handler()` si le code doit être appelé lors d'\"événements\" "
"déclenchés par d'autres objets imprimante. Chaque nom d'événement est une "
"chaîne de caractères, et par convention, c'est le nom du module source "
"principal déclenchant l'événement avec un nom court pour l'action produite ("
"par exemple, \"klippy:connect\"). Les paramètres passés à chaque "
"gestionnaire d'événement sont spécifiques à l'événement en question (tout "
"comme le traitement des exceptions et le contexte d'exécution). Deux "
"événements de démarrage courants sont :"

msgid ""
"klippy:connect - This event is generated after all printer objects are "
"instantiated. It is commonly used to lookup other printer objects, to verify"
" config settings, and to perform an initial \"handshake\" with printer "
"hardware."
msgstr ""
"klippy:connect - Cet événement est généré après l'instanciation de tous les "
"objets imprimante. Il est couramment utilisé pour rechercher d'autres objets "
"imprimante, pour vérifier les paramètres de configuration et pour effectuer "
"une première \"prise de contact\" avec le matériel de l'imprimante."

msgid ""
"klippy:ready - This event is generated after all connect handlers have "
"completed successfully. It indicates the printer is transitioning to a state"
" ready to handle normal operations. Do not raise an error in this callback."
msgstr ""
"klippy:ready - Cet événement est généré après que tous les gestionnaires de "
"connexion se soient terminés avec succès. Il indique que l'imprimante est en "
"train de passer à l'état prêt à gérer les opérations normales. Ne déclenchez "
"pas d'erreur dans ce rappel."

msgid ""
"If there is an error in the user's config, be sure to raise it during the "
"`load_config()` or \"connect event\" phases. Use either `raise "
"config.error(\"my error\")` or `raise printer.config_error(\"my error\")` to"
" report the error."
msgstr ""
"S'il y a une erreur dans la configuration de l'utilisateur, assurez-vous de "
"la signaler pendant les phases `load_config()` ou \"connect event\". "
"Utilisez soit `raise config.error(\"mon erreur\")` soit `raise printer."
"config_error(\"mon erreur\")` pour signaler l'erreur."

msgid ""
"Use the \"pins\" module to configure a pin on a micro-controller. This is "
"typically done with something similar to "
"`printer.lookup_object(\"pins\").setup_pin(\"pwm\", "
"config.get(\"my_pin\"))`. The returned object can then be commanded at run-"
"time."
msgstr ""
"Utilisez le module \"pins\" pour configurer une broche sur un micro-"
"contrôleur. Ceci est typiquement fait avec quelque chose de similaire à "
"`printer.lookup_object(\"pins\").setup_pin(\"pwm\", config.get(\"my_pin\"))`"
". L'objet retourné peut alors être commandé au moment de l'exécution."

msgid ""
"If the module needs access to system timing or external file descriptors "
"then use `printer.get_reactor()` to obtain access to the global \"event "
"reactor\" class. This reactor class allows one to schedule timers, wait for "
"input on file descriptors, and to \"sleep\" the host code."
msgstr ""
"Si le module doit accéder à la temporisation du système ou à des "
"descripteurs de fichiers externes, utilisez `printer.get_reactor()` pour "
"obtenir l'accès à la classe globale \"event reactor\". Cette classe de "
"réacteur permet de programmer des temporisations, d'attendre des entrées sur "
"des descripteurs de fichiers, et d'\"endormir\" le code hôte."

msgid ""
"Do not use global variables. All state should be stored in the printer "
"object returned from the `load_config()` function. This is important as "
"otherwise the RESTART command may not perform as expected. Also, for similar"
" reasons, if any external files (or sockets) are opened then be sure to "
"register a \"klippy:disconnect\" event handler and close them from that "
"callback."
msgstr ""
"N'utilisez pas de variables globales. Tous les états doivent être stockés "
"dans l'objet imprimante renvoyé par la fonction `load_config()`. Ceci est "
"important car sinon la commande RESTART pourrait ne pas fonctionner comme "
"prévu. De même, pour des raisons similaires, si des fichiers externes (ou "
"des sockets) sont ouverts, assurez-vous d'enregistrer un gestionnaire "
"d'événement \"klippy:disconnect\" et de les fermer à partir de ce rappel."

msgid ""
"Avoid accessing the internal member variables (or calling methods that start"
" with an underscore) of other printer objects. Observing this convention "
"makes it easier to manage future changes."
msgstr ""
"Évitez d'accéder aux variables membres internes (ou d'appeler les méthodes "
"commençant par un trait de soulignement) d'autres objets imprimante. Le "
"respect de cette convention facilite la gestion des modifications futures."

msgid ""
"If submitting the module for inclusion in the main Klipper code, be sure to "
"place a copyright notice at the top of the module. See the existing modules "
"for the preferred format."
msgstr ""
"Si vous soumettez le module pour qu'il soit inclus dans le code principal de "
"Klipper, veillez à placer un avis de copyright en haut du module. Consultez "
"les modules existants pour connaître le format préféré."

msgid "Adding new kinematics"
msgstr "Ajout de nouvelles cinématiques"

msgid ""
"This section provides some tips on adding support to Klipper for additional "
"types of printer kinematics. This type of activity requires excellent "
"understanding of the math formulas for the target kinematics. It also "
"requires software development skills - though one should only need to update"
" the host software."
msgstr ""
"Cette section fournit quelques conseils pour ajouter le support à Klipper de "
"types supplémentaires de cinématiques d'imprimante. Ce type d'activité "
"nécessite une excellente compréhension des formules mathématiques de la "
"cinématique cible. Elle requiert également des compétences en matière de "
"développement de logiciels, même s'il suffit de mettre à jour le logiciel "
"hôte."

msgid "Useful steps:"
msgstr "Les étapes utiles :"

msgid ""
"Start by studying the \"[code flow of a move](#code-flow-of-a-move-"
"command)\" section and the [Kinematics document](Kinematics.md)."
msgstr ""
"Commencez par étudier la section \"[code de flux d'un mouvement](#code-flow-"
"of-a-move-command)\" et le [document cinématiques](Kinematics.md)."

msgid ""
"Review the existing kinematic classes in the klippy/kinematics/ directory. "
"The kinematic classes are tasked with converting a move in cartesian "
"coordinates to the movement on each stepper. One should be able to copy one "
"of these files as a starting point."
msgstr ""
"Passez en revue les classes cinématiques existantes dans le répertoire "
"klippy/kinematics/. Les classes cinématiques sont chargées de convertir le "
"mouvement en coordonnées cartésiennes en un mouvement sur chaque moteur. On "
"devrait être capable de copier un de ces fichiers comme point de départ."

msgid ""
"Implement the C stepper kinematic position functions for each stepper if "
"they are not already available (see kin_cart.c, kin_corexy.c, and "
"kin_delta.c in klippy/chelper/). The function should call `move_get_coord()`"
" to convert a given move time (in seconds) to a cartesian coordinate (in "
"millimeters), and then calculate the desired stepper position (in "
"millimeters) from that cartesian coordinate."
msgstr ""
"Implémentez les fonctions de position cinématique du moteur en C pour chaque "
"moteur si elles ne sont pas déjà disponibles (voir kin_cart.c, kin_corexy.c, "
"et kin_delta.c dans klippy/chelper/). La fonction doit appeler "
"`move_get_coord()` pour convertir une durée de déplacement donnée (en "
"secondes) en coordonnées cartésiennes (en millimètres), et ensuite calculer "
"la position souhaitée du moteur (en millimètres) à partir de ces coordonnées "
"cartésiennes."

msgid ""
"Implement the `calc_position()` method in the new kinematics class. This "
"method calculates the position of the toolhead in cartesian coordinates from"
" the position of each stepper. It does not need to be efficient as it is "
"typically only called during homing and probing operations."
msgstr ""
"Implémentez la méthode `calc_position()` dans la nouvelle classe "
"cinématique. Cette méthode calcule la position de la tête de l'outil en "
"coordonnées cartésiennes à partir de la position de chaque moteur. Elle n'a "
"pas besoin d'être efficace car elle n'est typiquement appelée que pendant "
"les opérations de mise à l'origine et de palpage."

msgid ""
"Other methods. Implement the `check_move()`, `get_status()`, "
"`get_steppers()`, `home()`, and `set_position()` methods. These functions "
"are typically used to provide kinematic specific checks. However, at the "
"start of development one can use boiler-plate code here."
msgstr ""
"Autres méthodes. Implémentez les méthodes `check_move()`, `get_status()`, "
"`get_steppers()`, `home()`, et `set_position()`. Ces fonctions sont "
"typiquement utilisées pour fournir des vérifications spécifiques à la "
"cinématique. Cependant, au début du développement, on peut utiliser du code "
"passe-partout ici."

msgid ""
"Implement test cases. Create a g-code file with a series of moves that can "
"test important cases for the given kinematics. Follow the [debugging "
"documentation](Debugging.md) to convert this g-code file to micro-controller"
" commands. This is useful to exercise corner cases and to check for "
"regressions."
msgstr ""
"Implémenter des cas de test. Créez un fichier g-code avec une série de "
"mouvements pouvant tester des cas importants pour la cinématique donnée. "
"Suivez la [documentation de débogage](Debugging.md) pour convertir ce "
"fichier g-code en commandes de micro-contrôleur. Ceci est utile pour tester "
"les cas extrêmes et vérifier les régressions."

msgid "Porting to a new micro-controller"
msgstr "Portage sur un nouveau microcontrôleur"

msgid ""
"This section provides some tips on porting Klipper's micro-controller code "
"to a new architecture. This type of activity requires good knowledge of "
"embedded development and hands-on access to the target micro-controller."
msgstr ""
"Cette section fournit quelques conseils sur le portage du code du "
"microcontrôleur de Klipper vers une nouvelle architecture. Ce type "
"d'activité nécessite une bonne connaissance du développement embarqué et un "
"accès pratique au microcontrôleur cible."

msgid ""
"Start by identifying any 3rd party libraries that will be used during the "
"port. Common examples include \"CMSIS\" wrappers and manufacturer \"HAL\" "
"libraries. All 3rd party code needs to be GNU GPLv3 compatible. The 3rd "
"party code should be committed to the Klipper lib/ directory. Update the "
"lib/README file with information on where and when the library was obtained."
" It is preferable to copy the code into the Klipper repository unchanged, "
"but if any changes are required then those changes should be listed "
"explicitly in the lib/README file."
msgstr ""
"Commencez par identifier toutes les bibliothèques tierces qui seront "
"utilisées pendant le portage. Les exemples courants incluent les wrappers "
"\"CMSIS\" et les bibliothèques \"HAL\" des fabricants. Tout code tiers doit "
"être compatible avec la licence GNU GPLv3. Le code tiers doit être livré "
"dans le répertoire Klipper lib/. Mettez à jour le fichier lib/README en "
"indiquant où et quand la bibliothèque a été obtenue. Il est préférable de "
"copier le code dans le dépôt Klipper sans modification, mais si des "
"modifications sont nécessaires, elles doivent être indiquées explicitement "
"dans le fichier lib/README."

msgid ""
"Create a new architecture sub-directory in the src/ directory and add "
"initial Kconfig and Makefile support. Use the existing architectures as a "
"guide. The src/simulator provides a basic example of a minimum starting "
"point."
msgstr ""
"Créer un nouveau sous-répertoire d'architecture dans le répertoire src/ et "
"ajouter le support initial de Kconfig et Makefile. Utilisez les "
"architectures existantes comme guide. Le simulateur src/simulator fournit un "
"exemple de base pour un point de départ minimal."

msgid ""
"Get familiar with the the console.py tool (as described in the [debugging "
"document](Debugging.md)) and verify connectivity to the micro-controller "
"with it. This tool translates the low-level micro-controller communication "
"protocol to a human readable form."
msgstr ""
"Familiarisez-vous avec l'outil console.py (comme décrit dans le [document de "
"débogage](Debugging.md)) et vérifiez la connectivité au microcontrôleur avec "
"cet outil. Cet outil traduit le protocole de communication de bas niveau du "
"microcontrôleur en une forme lisible par l'homme."

msgid ""
"Create a sample Klipper config file in the config/ directory. Test the "
"micro-controller with the main klippy.py program."
msgstr ""
"Créez un exemple de fichier de configuration Klipper dans le répertoire "
"config/. Testez le micro-contrôleur avec le programme principal klippy.py."

msgid "Consider adding build test cases in the test/ directory."
msgstr ""
"Pensez à ajouter des cas de test de construction dans le répertoire test/."

msgid "Coordinate Systems"
msgstr "Les systèmes de coordonnées"

msgid ""
"Internally, Klipper primarily tracks the position of the toolhead in "
"cartesian coordinates that are relative to the coordinate system specified "
"in the config file. That is, most of the Klipper code will never experience "
"a change in coordinate systems. If the user makes a request to change the "
"origin (eg, a `G92` command) then that effect is obtained by translating "
"future commands to the primary coordinate system."
msgstr ""
"En interne, Klipper suit principalement la position de la tête de l'outil en "
"coordonnées cartésiennes relatives au système de coordonnées spécifié dans "
"le fichier de configuration. C'est-à-dire que la plupart du code de Klipper "
"ne connaîtra jamais de changement de système de coordonnées. Si "
"l'utilisateur fait une demande pour changer l'origine (par exemple, une "
"commande `G92`) alors cet effet est obtenu en traduisant les commandes "
"futures vers le système de coordonnées primaires."

msgid ""
"However, in some cases it is useful to obtain the toolhead position in some "
"other coordinate system and Klipper has several tools to facilitate that. "
"This can be seen by running the GET_POSITION command. For example:"
msgstr ""
"Cependant, dans certains cas, il est utile d'obtenir la position de la tête "
"de l'outil dans un autre système de coordonnées et Klipper dispose de "
"plusieurs outils pour faciliter cela. Vous pouvez le constater en exécutant "
"la commande GET_POSITION. Par exemple :"

msgid ""
"The \"stepper\" position (`stepper.get_commanded_position()`) is the "
"position of the given stepper as tracked by the kinematics code. This "
"generally corresponds to the position (in mm) of the carriage along its "
"rail, relative to the position_endstop specified in the config file. (Some "
"kinematics track stepper positions in radians instead of millimeters.) If "
"the robot is in motion when the query is issued then the reported value "
"includes moves buffered on the micro-controller, but does not include moves "
"on the look-ahead queue. One may use the `toolhead.flush_step_generation()` "
"or `toolhead.wait_moves()` calls to fully flush the look-ahead and step "
"generation code."
msgstr ""
"La position \"stepper\" (`stepper.get_commanded_position()`) est la position "
"du moteur donné telle qu'elle est suivie par le code cinématique. Cela "
"correspond généralement à la position (en mm) du chariot le long de son "
"rail, par rapport à la position_endstop indiquée dans le fichier de "
"configuration. (Si le robot est en mouvement lorsque la requête est émise, "
"la valeur rapportée inclut les mouvements mis en mémoire tampon sur le micro-"
"contrôleur, mais n'inclut pas les mouvements de la file d'attente look-"
"ahead. On peut utiliser les appels `toolhead.flush_step_generation()` ou "
"`toolhead.wait_moves()` pour vider complètement les codes de look-ahead et "
"de génération de pas."

msgid ""
"The \"kinematic\" position (`kin.calc_position()`) is the cartesian position"
" of the toolhead as derived from \"stepper\" positions and is relative to "
"the coordinate system specified in the config file. This may differ from the"
" requested cartesian position due to the granularity of the stepper motors. "
"If the robot is in motion when the \"stepper\" positions are taken then the "
"reported value includes moves buffered on the micro-controller, but does not"
" include moves on the look-ahead queue. One may use the "
"`toolhead.flush_step_generation()` or `toolhead.wait_moves()` calls to fully"
" flush the look-ahead and step generation code."
msgstr ""
"La position \"kinematic\" (`kin.calc_position()`) est la position "
"cartésienne de la tête de l'outil telle que dérivée des positions \"pas à "
"pas\" et est relative au système de coordonnées spécifié dans le fichier de "
"configuration. Cela peut différer de la position cartésienne demandée en "
"raison de la granularité des moteurs pas à pas. Si le robot est en mouvement "
"lorsque les positions \"stepper\" sont prises, la valeur rapportée inclut "
"les mouvements mis en mémoire tampon sur le micro-contrôleur, mais n'inclut "
"pas les mouvements de la file d'attente look-ahead. On peut utiliser les "
"appels `toolhead.flush_step_generation()` ou `toolhead.wait_moves()` pour "
"vider complètement le code de look-ahead et de génération de pas."

msgid ""
"The \"toolhead\" position (`toolhead.get_position()`) is the last requested "
"position of the toolhead in cartesian coordinates relative to the coordinate"
" system specified in the config file. If the robot is in motion when the "
"query is issued then the reported value includes all requested moves (even "
"those in buffers waiting to be issued to the stepper motor drivers)."
msgstr ""
"La position de la tête d'outil (`toolhead.get_position()`) est la dernière "
"position demandée de la tête d'outil en coordonnées cartésiennes par rapport "
"au système de coordonnées spécifié dans le fichier de configuration. Si le "
"robot est en mouvement lorsque la requête est émise, la valeur rapportée "
"inclut tous les déplacements demandés (même ceux dans les tampons en attente "
"d'être émis vers les pilotes de moteurs pas à pas)."

msgid ""
"The \"gcode\" position is the last requested position from a `G1` (or `G0`) "
"command in cartesian coordinates relative to the coordinate system specified"
" in the config file. This may differ from the \"toolhead\" position if a "
"g-code transformation (eg, bed_mesh, bed_tilt, skew_correction) is in "
"effect. This may differ from the actual coordinates specified in the last "
"`G1` command if the g-code origin has been changed (eg, `G92`, "
"`SET_GCODE_OFFSET`, `M221`). The `M114` command "
"(`gcode_move.get_status()['gcode_position']`) will report the last g-code "
"position relative to the current g-code coordinate system."
msgstr ""
"La position \"gcode\" est la dernière position demandée par une commande `G1`"
" (ou `G0`) en coordonnées cartésiennes par rapport au système de coordonnées "
"spécifié dans le fichier de configuration. Elle peut différer de la position "
"\"toolhead\" si une transformation g-code (par exemple, bed_mesh, bed_tilt, "
"skew_correction) est en cours. Cela peut différer des coordonnées réelles "
"spécifiées dans la dernière commande `G1` si l'origine du gcode a été "
"modifiée (par exemple, `G92`, `SET_GCODE_OFFSET`, `M221`). La commande `M114`"
" (`gcode_move.get_status()['gcode_position']`) indiquera la dernière "
"position du g-code par rapport au système de coordonnées actuel du g-code."

msgid ""
"The \"gcode base\" is the location of the g-code origin in cartesian "
"coordinates relative to the coordinate system specified in the config file. "
"Commands such as `G92`, `SET_GCODE_OFFSET`, and `M221` alter this value."
msgstr ""
"La \"base gcode\" est l'emplacement de l'origine du g-code en coordonnées "
"cartésiennes par rapport au système de coordonnées spécifié dans le fichier "
"de configuration. Les commandes telles que `G92`, `SET_GCODE_OFFSET`, et "
"`M221` modifient cette valeur."

msgid ""
"The \"gcode homing\" is the location to use for the g-code origin (in "
"cartesian coordinates relative to the coordinate system specified in the "
"config file) after a `G28` home command. The `SET_GCODE_OFFSET` command can "
"alter this value."
msgstr ""
"Le \"gcode homing\" est l'emplacement à utiliser pour l'origine du g-code ("
"en coordonnées cartésiennes par rapport au système de coordonnées spécifié "
"dans le fichier de configuration) après une commande de mise à l'origine "
"`G28`. La commande `SET_GCODE_OFFSET` peut modifier cette valeur."

msgid "Time"
msgstr "Temporisation"

msgid ""
"Fundamental to the operation of Klipper is the handling of clocks, times, "
"and timestamps. Klipper executes actions on the printer by scheduling events"
" to occur in the near future. For example, to turn on a fan, the code might "
"schedule a change to a GPIO pin in a 100ms. It is rare for the code to "
"attempt to take an instantaneous action. Thus, the handling of time within "
"Klipper is critical to correct operation."
msgstr ""
"La manipulation des horloges, des durées et des horodatages est fondamentale "
"pour le fonctionnement de Klipper. Celui-ci exécute des actions sur "
"l'imprimante en programmant des événements qui se produiront dans un avenir "
"proche. Par exemple, pour allumer un ventilateur, le code peut programmer un "
"changement sur une broche GPIO dans 100 ms. Il est rare que le code tente "
"d'effectuer une action instantanée. Ainsi, la gestion du temps dans Klipper "
"est essentielle pour un fonctionnement correct."

msgid ""
"There are three types of times tracked internally in the Klipper host "
"software:"
msgstr ""
"Il existe trois types de temporisations suivis en interne dans le logiciel "
"hôte Klipper :"

msgid ""
"System time. The system time uses the system's monotonic clock - it is a "
"floating point number stored as seconds and it is (generally) relative to "
"when the host computer was last started. System times have limited use in "
"the software - they are primarily used when interacting with the operating "
"system. Within the host code, system times are frequently stored in "
"variables named *eventtime* or *curtime*."
msgstr ""
"Heure du système. L'heure système utilise l'horloge du système - c'est un "
"nombre à virgule flottante stocké sous forme de secondes (généralement) "
"relatif à la date du dernier démarrage de l'ordinateur hôte. Les temps "
"système ont un usage limité dans le logiciel - ils sont principalement "
"utilisés lors de l'interaction avec le système d'exploitation. Dans le code "
"hôte, les heures système sont souvent stockées dans des variables nommées "
"*eventtime* ou *curtime*."

msgid ""
"Print time. The print time is synchronized to the main micro-controller "
"clock (the micro-controller defined in the \"[mcu]\" config section). It is "
"a floating point number stored as seconds and is relative to when the main "
"mcu was last restarted. It is possible to convert from a \"print time\" to "
"the main micro-controller's hardware clock by multiplying the print time by "
"the mcu's statically configured frequency rate. The high-level host code "
"uses print times to calculate almost all physical actions (eg, head "
"movement, heater changes, etc.). Within the host code, print times are "
"generally stored in variables named *print_time* or *move_time*."
msgstr ""
"Temps d'impression. Le temps d'impression est synchronisé avec l'horloge du "
"micro-contrôleur principal (le micro-contrôleur défini dans la section \""
"[mcu]\" de la configuration). C'est un nombre à virgule flottante stocké en "
"secondes relatif à la date du dernier redémarrage du micro-contrôleur "
"principal. Il est possible de convertir un \"temps d'impression\" en horloge "
"matérielle du micro-contrôleur principal en multipliant le temps "
"d'impression par le taux de fréquence du mcu configuré statiquement. Le code "
"hôte de haut niveau utilise les temps d'impression pour calculer presque "
"toutes les actions physiques (par exemple, le mouvement de la tête, les "
"changements de chauffage, etc.) Dans le code hôte, les temps d'impression "
"sont généralement stockés dans des variables nommées *print_time* ou "
"*move_time*."

msgid ""
"MCU clock. This is the hardware clock counter on each micro-controller. It "
"is stored as an integer and its update rate is relative to the frequency of "
"the given micro-controller. The host software translates its internal times "
"to clocks before transmission to the mcu. The mcu code only ever tracks time"
" in clock ticks. Within the host code, clock values are tracked as 64bit "
"integers, while the mcu code uses 32bit integers. Within the host code, "
"clocks are generally stored in variables with names containing *clock* or "
"*ticks*."
msgstr ""
"Horloge MCU. Il s'agit du compteur d'horloge matériel de chaque micro-"
"contrôleur. Il est stocké sous forme d'un nombre entier et son taux de mise "
"à jour est relatif à la fréquence du micro-contrôleur donné. Le logiciel "
"hôte convertit ses temps internes en horloges avant de les transmettre à "
"l'unité centrale. Le code de l'unité centrale de traitement ne suit jamais "
"le temps qu'en ticks d'horloge. Dans le code hôte, les valeurs d'horloge "
"sont suivies sous forme d'entiers de 64 bits, alors que le code de l'unité "
"centrale utilise des entiers de 32 bits. Dans le code hôte, les horloges "
"sont généralement stockées dans des variables dont les noms contiennent "
"*clock* ou *ticks*."

msgid ""
"Conversion between the different time formats is primarily implemented in "
"the **klippy/clocksync.py** code."
msgstr ""
"La conversion entre les différents formats de temps est principalement "
"implémentée dans le code **klippy/clocksync.py**."

msgid "Some things to be aware of when reviewing the code:"
msgstr "Quelques éléments à prendre en compte lors de la révision du code :"

msgid ""
"32bit and 64bit clocks: To reduce bandwidth and to improve micro-controller "
"efficiency, clocks on the micro-controller are tracked as 32bit integers. "
"When comparing two clocks in the mcu code, the `timer_is_before()` function "
"must always be used to ensure integer rollovers are handled properly. The "
"host software converts 32bit clocks to 64bit clocks by appending the high-"
"order bits from the last mcu timestamp it has received - no message from the"
" mcu is ever more than 2^31 clock ticks in the future or past so this "
"conversion is never ambiguous. The host converts from 64bit clocks to 32bit "
"clocks by simply truncating the high-order bits. To ensure there is no "
"ambiguity in this conversion, the **klippy/chelper/serialqueue.c** code will"
" buffer messages until they are within 2^31 clock ticks of their target "
"time."
msgstr ""
"Horloges 32bit et 64bit : Pour réduire la bande passante et améliorer "
"l'efficacité du micro-contrôleur, les horloges sur le micro-contrôleur sont "
"suivies comme des entiers 32bit. Lors de la comparaison de deux horloges "
"dans le code mcu, la fonction `timer_is_before()` doit toujours être "
"utilisée pour s'assurer que les renversements d'entiers sont traités "
"correctement. Le logiciel hôte convertit les horloges 32bit en horloges "
"64bit en ajoutant les bits de poids fort du dernier timestamp mcu qu'il a "
"reçu - aucun message du mcu n'est jamais plus de 2^31 ticks d'horloge dans "
"le futur ou le passé, donc cette conversion n'est jamais ambiguë. L'hôte "
"convertit les horloges de 64 bits en horloges de 32 bits en tronquant "
"simplement les bits de poids fort. Pour s'assurer qu'il n'y a pas "
"d'ambiguïté dans cette conversion, le code **klippy/chelper/serialqueue.c** "
"mettra en mémoire tampon les messages jusqu'à ce qu'ils soient dans les 2^31 "
"ticks d'horloge de leur temps cible."

msgid ""
"Multiple micro-controllers: The host software supports using multiple micro-"
"controllers on a single printer. In this case, the \"MCU clock\" of each "
"micro-controller is tracked separately. The clocksync.py code handles clock "
"drift between micro-controllers by modifying the way it converts from "
"\"print time\" to \"MCU clock\". On secondary mcus, the mcu frequency that "
"is used in this conversion is regularly updated to account for measured "
"drift."
msgstr ""
"Microcontrôleurs multiples : Le logiciel hôte permet d'utiliser plusieurs "
"microcontrôleurs sur une seule imprimante. Dans ce cas, l'\"horloge MCU\" de "
"chaque microcontrôleur est suivie séparément. Le code clocksync.py gère la "
"dérive de l'horloge entre les micro-contrôleurs en modifiant la façon dont "
"il convertit le \"temps d'impression\" en \"horloge MCU\". Sur les mcus "
"secondaires, la fréquence du mcu utilisée dans cette conversion est "
"régulièrement mise à jour pour tenir compte de la dérive mesurée."

msgid ""
"Send: GET_POSITION\n"
"Recv: // mcu: stepper_a:-2060 stepper_b:-1169 stepper_c:-1613\n"
"Recv: // stepper: stepper_a:457.254159 stepper_b:466.085669 stepper_c:465.382132\n"
"Recv: // kinematic: X:8.339144 Y:-3.131558 Z:233.347121\n"
"Recv: // toolhead: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode base: X:0.000000 Y:0.000000 Z:0.000000 E:0.000000\n"
"Recv: // gcode homing: X:0.000000 Y:0.000000 Z:0.000000\n"
msgstr ""
"Send: GET_POSITION\n"
"Recv: // mcu: stepper_a:-2060 stepper_b:-1169 stepper_c:-1613\n"
"Recv: // stepper: stepper_a:457.254159 stepper_b:466.085669 stepper_c:465."
"382132\n"
"Recv: // kinematic: X:8.339144 Y:-3.131558 Z:233.347121\n"
"Recv: // toolhead: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode base: X:0.000000 Y:0.000000 Z:0.000000 E:0.000000\n"
"Recv: // gcode homing: X:0.000000 Y:0.000000 Z:0.000000\n"

#: docs/Code_Overview.md:block 1 (header)
msgid "Code overview"
msgstr "Aperçu du code"

#: docs/Code_Overview.md:block 43 (paragraph)
msgid ""
"The \"mcu\" position (`stepper.get_mcu_position()` in the code) is the total"
" number of steps the micro-controller has issued in a positive direction "
"minus the number of steps issued in a negative direction since the micro-"
"controller was last reset. If the robot is in motion when the query is "
"issued then the reported value includes moves buffered on the micro-"
"controller, but does not include moves on the look-ahead queue."
msgstr ""
"La position \"mcu\" (`stepper.get_mcu_position()` dans le code) est le "
"nombre total de pas que le micro-contrôleur a émis dans un sens positif "
"moins le nombre de pas émis dans un sens négatif depuis la dernière "
"réinitialisation du micro-contrôleur. Si le robot est en mouvement lorsque "
"la requête est émise, la valeur rapportée inclut les mouvements mis en "
"mémoire tampon dans le microcontrôleur, mais pas les mouvements de la file "
"d'attente de surveillance."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Add support for timer dispatch from hardware interrupts. See Klipper [commit"
" "
"970831ee](https://github.com/Klipper3d/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)"
" as an example of steps 1-5 done for the LPC176x architecture."
msgstr ""
"Ajouter le support pour la distribution des timers à partir des "
"interruptions matérielles. Voir Klipper [commit 970831ee](https://github.com/"
"Klipper3d/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f) comme "
"exemple des étapes 1-5 réalisées pour l'architecture LPC176x."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Bring up basic GPIO input and output support. See Klipper [commit "
"c78b9076](https://github.com/Klipper3d/klipper/commit/c78b90767f19c9e8510c3155b89fb7ad64ca3c54)"
" as an example of this."
msgstr ""
"Apporter le support de base des entrées et sorties GPIO. Voir Klipper ["
"commit c78b9076](https://github.com/Klipper3d/klipper/commit/"
"c78b90767f19c9e8510c3155b89fb7ad64ca3c54) comme exemple."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Bring up additional peripherals - for example see Klipper commit "
"[65613aed](https://github.com/Klipper3d/klipper/commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27),"
" "
"[c812a40a](https://github.com/Klipper3d/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5),"
" and "
"[c381d03a](https://github.com/Klipper3d/klipper/commit/c381d03aad5c3ee761169b7c7bced519cc14da29)."
msgstr ""
"Faire apparaître des périphériques supplémentaires - par exemple, voir "
"Klipper commit [65613aed](https://github.com/Klipper3d/klipper/commit/"
"65613aeddfb9ef86905cb1dade9e773a02ef3c27), [c812a40a](https://github.com/"
"Klipper3d/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5), et "
"[c381d03a](https://github.com/Klipper3d/klipper/commit/"
"c381d03aad5c3ee761169b7c7bced519cc14da29)."

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"If the printer object defines a `get_status()` method then the module can "
"export [status information](Status_Reference.md) via "
"[macros](Command_Templates.md) and via the [API Server](API_Server.md). The "
"`get_status()` method must return a Python dictionary with keys that are "
"strings and values that are integers, floats, strings, lists, dictionaries, "
"True, False, or None. Tuples (and named tuples) may also be used (these "
"appear as lists when accessed via the API Server). Lists and dictionaries "
"that are exported must be treated as \"immutable\" - if their contents "
"change then a new object must be returned from `get_status()`, otherwise the"
" API Server will not detect those changes."
msgstr ""
"Si l'objet imprimante définit une méthode `get_status()`, le module peut "
"exporter des [informations d'état](Status_Reference.md) via des "
"[macros](Command_Templates.md) et via le [serveur API](API_Server.md). La "
"méthode `get_status()` doit retourner un dictionnaire Python dont les clés "
"sont des chaînes de caractères et les valeurs des entiers, des flottants, "
"des chaînes de caractères, des listes, des dictionnaires, True, False ou "
"None. Les tuples (et les tuples nommés) peuvent également être utilisés (ils "
"apparaissent comme des listes lorsqu'on y accède via le serveur API). Les "
"listes et les dictionnaires exportés doivent être traités comme \"immuables\""
" - si leur contenu change, un nouvel objet doit être renvoyé par "
"`get_status()`, sinon le serveur API ne détectera pas ces changements."

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"It is recommended to assign a value to all member variables in the Python "
"constructor of Python classes. (And therefore avoid utilizing Python's "
"ability to dynamically create new member variables.)"
msgstr ""
"Il est recommandé d'attribuer une valeur à toutes les variables membres dans "
"le constructeur Python des classes Python. (Et donc d'éviter d'utiliser la "
"capacité de Python à créer dynamiquement de nouvelles variables membres.)"

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"If a Python variable is to store a floating point value then it is "
"recommended to always assign and manipulate that variable with floating "
"point constants (and never use integer constants). For example, prefer "
"`self.speed = 1.` over `self.speed = 1`, and prefer `self.speed = 2. * x` "
"over `self.speed = 2 * x`. Consistent use of floating point values can avoid"
" hard to debug quirks in Python type conversions."
msgstr ""
"Si une variable Python doit stocker une valeur en virgule flottante, il est "
"recommandé de toujours affecter et manipuler cette variable avec des "
"constantes en virgule flottante (et de ne jamais utiliser de constantes "
"entières). Par exemple, préférez `self.speed = 1.` à `self.speed = 1`, et "
"préférez `self.speed = 2. * x` plutôt que `self.speed = 2 * x`. "
"L'utilisation cohérente des valeurs à virgule flottante peut éviter des "
"bizarreries difficiles à déboguer dans les conversions de types Python."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"The first main coding task is to bring up communication support to the "
"target board. This is the most difficult step in a new port. Once basic "
"communication is working, the remaining steps tend to be much easier. It is "
"typical to use a UART type serial device during initial development as these"
" types of hardware devices are generally easier to enable and control. "
"During this phase, make liberal use of helper code from the src/generic/ "
"directory (check how src/simulator/Makefile includes the generic C code into"
" the build). It is also necessary to define timer_read_time() (which returns"
" the current system clock) in this phase, but it is not necessary to fully "
"support timer irq handling."
msgstr ""
"La première tâche principale de codage est d'apporter le support de "
"communication à la carte cible. C'est l'étape la plus difficile dans un "
"nouveau portage. Une fois que la communication de base fonctionne, les "
"autres étapes ont tendance à être beaucoup plus faciles. Il est typique "
"d'utiliser un dispositif série de type UART pendant le développement initial "
"car ces types de dispositifs matériels sont généralement plus faciles à "
"activer et à contrôler. Pendant cette phase, faites un usage libéral du code "
"d'aide du répertoire src/generic/ (vérifiez comment src/simulator/Makefile "
"inclut le code C générique dans la compilation). Il est également nécessaire "
"de définir timer_read_time() (qui renvoie l'horloge système actuelle) dans "
"cette phase, mais il n'est pas nécessaire de supporter complètement la "
"gestion des irq des timers."

#: docs/Code_Overview.md:block 39 (paragraph)
msgid "Additional coding tips:"
msgstr "Conseils supplémentaires pour le codage :"

#: docs/Code_Overview.md:block 40 (ordered list)
msgid ""
"Avoid using \"C bitfields\" to access IO registers; prefer direct read and "
"write operations of 32bit, 16bit, or 8bit integers. The C language "
"specifications don't clearly specify how the compiler must implement C "
"bitfields (eg, endianness, and bit layout), and it's difficult to determine "
"what IO operations will occur on a C bitfield read or write."
msgstr ""
"Évitez d'utiliser des \"champs de bits C\" pour accéder aux registres d'E/S ;"
" préférez les opérations directes de lecture et d'écriture d'entiers de 32, "
"16 ou 8 bits. Les spécifications du langage C ne précisent pas clairement "
"comment le compilateur doit implémenter les champs de bits C (par exemple, "
"l'endianness et la disposition des bits), et il est difficile de déterminer "
"quelles opérations d'E/S se produiront lors de la lecture ou de l'écriture "
"d'un champ de bits C."

#: docs/Code_Overview.md:block 40 (ordered list)
msgid ""
"Prefer writing explicit values to IO registers instead of using read-modify-"
"write operations. That is, if updating a field in an IO register where the "
"other fields have known values, then it is preferable to explicitly write "
"the full contents of the register. Explicit writes produce code that is "
"smaller, faster, and easier to debug."
msgstr ""
"Préférez l'écriture de valeurs explicites dans les registres d'E/S à "
"l'utilisation d'opérations de lecture-modification-écriture. Autrement dit, "
"si l'on met à jour un champ dans un registre d'E/S dont les autres champs "
"ont des valeurs connues, il est préférable d'écrire explicitement le contenu "
"complet du registre. Les écritures explicites produisent un code plus petit, "
"plus rapide et plus facile à déboguer."

#: docs/Code_Overview.md:block 14 (paragraph)
msgid ""
"Task, init, and command functions always run with interrupts enabled "
"(however, they can temporarily disable interrupts if needed). These "
"functions should avoid long pauses, delays, or do work that lasts a "
"significant time. (Long delays in these \"task\" functions result in "
"scheduling jitter for other \"tasks\" - delays over 100us may become "
"noticeable, delays over 500us may result in command retransmissions, delays "
"over 100ms may result in watchdog reboots.) These functions schedule work at"
" specific times by scheduling timers."
msgstr ""
"Les fonctions de tâche, d'initialisation et de commande s'exécutent toujours "
"avec les interruptions activées (toutefois, elles peuvent désactiver "
"temporairement les interruptions si nécessaire). Ces fonctions doivent "
"éviter les longues pauses, les retards, ou effectuer un travail qui dure un "
"temps significatif. (Les longs retards de ces fonctions \"tâches\" "
"entraînent une gigue de programmation pour d'autres \"tâches\" - les retards "
"de plus de 100us peuvent devenir perceptibles, les retards de plus de 500us "
"peuvent entraîner des retransmissions de commandes, les retards de plus de "
"100ms peuvent entraîner des redémarrages du chien de garde). Ces fonctions "
"planifient le travail à des moments précis en programmant des minuteries."

#~ msgid ""
#~ "Task, init, and command functions always run with interrupts enabled "
#~ "(however, they can temporarily disable interrupts if needed). These "
#~ "functions should never pause, delay, or do any work that lasts more than a "
#~ "few micro-seconds. These functions schedule work at specific times by "
#~ "scheduling timers."
#~ msgstr ""

#~ msgid ""
#~ "The first main coding task is to bring up communication support to the "
#~ "target board. This is the most difficult step in a new port. Once basic "
#~ "communication is working, the remaining steps tend to be much easier. It is "
#~ "typical to use an RS-232 style serial port during initial development as "
#~ "these types of hardware devices are generally easier to enable and control. "
#~ "During this phase, make liberal use of helper code from the src/generic/ "
#~ "directory (check how src/simulator/Makefile includes the generic C code into"
#~ " the build). It is also necessary to define timer_read_time() (which returns"
#~ " the current system clock) in this phase, but it is not necessary to fully "
#~ "support timer irq handling."
#~ msgstr ""

#~ msgid ""
#~ "Add support for timer dispatch from hardware interrupts. See Klipper [commit"
#~ " "
#~ "970831ee](https://github.com/KevinOConnor/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)"
#~ " as an example of steps 1-5 done for the LPC176x architecture."
#~ msgstr ""

#~ msgid ""
#~ "Bring up basic GPIO input and output support. See Klipper [commit "
#~ "c78b9076](https://github.com/KevinOConnor/klipper/commit/c78b90767f19c9e8510c3155b89fb7ad64ca3c54)"
#~ " as an example of this."
#~ msgstr ""

#~ msgid ""
#~ "Bring up additional peripherals - for example see Klipper commit "
#~ "[65613aed](https://github.com/KevinOConnor/klipper/commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27),"
#~ " "
#~ "[c812a40a](https://github.com/KevinOConnor/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5),"
#~ " and "
#~ "[c381d03a](https://github.com/KevinOConnor/klipper/commit/c381d03aad5c3ee761169b7c7bced519cc14da29)."
#~ msgstr ""

#~ msgid ""
#~ "The \"mcu\" position (`stepper.get_mcu_position()` in the code) is the total"
#~ " number of steps the micro-controller has issued in a positive direction "
#~ "minus the number of steps issued in a negative direction since the micro-"
#~ "controller was last reset. The value reported is only valid after the "
#~ "stepper has been homed. If the robot is in motion when the query is issued "
#~ "then the reported value includes moves buffered on the micro-controller, but"
#~ " does not include moves on the look-ahead queue."
#~ msgstr ""
